<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>盒木</title>
        <link>https://kingsqiu.github.io/</link>
        <description>Recent content on 盒木</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 04 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://kingsqiu.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>测试基础方法</title>
        <link>https://kingsqiu.github.io/p/test-ways/</link>
        <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/test-ways/</guid>
        <description>&lt;h2 id=&#34;黒白灰盒测试&#34;&gt;黒、白、灰盒测试&lt;/h2&gt;
&lt;h3 id=&#34;黑盒测试&#34;&gt;黑盒测试&lt;/h3&gt;
&lt;p&gt;黑盒测试把被测对象看成一个黑匣子，只考虑期整体的特性，不考虑期内部具体实现。&lt;/p&gt;
&lt;p&gt;黑盒测试的被测对象可以是一个系统、一个子系统、一模块、子模块、一个函数等。&lt;/p&gt;
&lt;p&gt;黑盒测试又可以被称为基于规格的测试。&lt;/p&gt;
&lt;h4 id=&#34;常见的黑盒测试类型&#34;&gt;&lt;strong&gt;常见的黑盒测试类型&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;功能性测试
&lt;ul&gt;
&lt;li&gt;一种是顺序测试每个程序特性或功能；&lt;/li&gt;
&lt;li&gt;另一种是一个模块一个模块的测试，即每个功能在其最先调用的地方被测试；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容量测试，检测软件在处理海量数据时的局限性，能发现系统效率方面的问题。&lt;/li&gt;
&lt;li&gt;负载测试，检测系统在短时间内处理巨大的数据量或执行许多功能调用上的能力。&lt;/li&gt;
&lt;li&gt;恢复性测试，主要保证系统在崩溃后能回复外部数据的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;白盒测试&#34;&gt;白盒测试&lt;/h3&gt;
&lt;p&gt;白盒测试是依据被测软件分析程序内部构造，并根据内部构造设计用例，来对内部控制流程进行测试，可完全不顾程序的整体功能实现情况。&lt;/p&gt;
&lt;p&gt;白盒测试是基于程序结构的逻辑驱动测试。&lt;/p&gt;
&lt;p&gt;白盒测试又可以被称为玻璃盒测试、透明盒测试、开放盒测试、结构化测试、逻辑驱动测试。&lt;/p&gt;
&lt;p&gt;白盒测试一般在测试前期进行，通过达到一定的逻辑覆盖率指标，使得软件内部逻辑控制结构上的问题能基本得到解决。&lt;/p&gt;
&lt;p&gt;白盒测试能保证内部逻辑结构能达到一定的覆盖程度，能够给予软件代码质量更大的保证。&lt;/p&gt;
&lt;p&gt;白盒测试发现问题后解决问题的成本较低，毕竟介入的早嘛。&lt;/p&gt;
&lt;p&gt;白盒测试一般会用到静态分析和动态分析两类技术，常用的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态分析：控制流分析、数据流分析、信息流分析；&lt;/li&gt;
&lt;li&gt;动态分析：逻辑覆盖测试（分支测试、路径测试等）、程序插桩等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;白盒测试的特点&#34;&gt;&lt;strong&gt;白盒测试的特点&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;测试人员需要了解软件的实现；&lt;/li&gt;
&lt;li&gt;可以检测代码中的每一条分支和路径；&lt;/li&gt;
&lt;li&gt;揭示隐藏在代码代码中的错误；&lt;/li&gt;
&lt;li&gt;对代码的测试相对彻底；&lt;/li&gt;
&lt;li&gt;实现代码结构上的优化；&lt;/li&gt;
&lt;li&gt;白盒测试的投入较大，成本高；&lt;/li&gt;
&lt;li&gt;白盒测试不验证（需求）规格的正确性；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;逻辑覆盖率测试&#34;&gt;&lt;strong&gt;逻辑覆盖率测试&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;根据覆盖的对象不同，存在多种逻辑覆盖测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语句覆盖；&lt;/li&gt;
&lt;li&gt;判定覆盖；&lt;/li&gt;
&lt;li&gt;条件覆盖；&lt;/li&gt;
&lt;li&gt;判定-条件覆盖；&lt;/li&gt;
&lt;li&gt;路径覆盖；&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而逻辑覆盖率的统计是通过&lt;strong&gt;程序插桩&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序插桩：&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e7%a8%8b%e5%ba%8f%e6%8f%92%e6%a1%a9&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程序插桩&lt;/a&gt;，最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e6%8e%a2%e9%92%88/1846154&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;探针&lt;/a&gt;（又称为“探测仪”，本质上就是进行信息采集的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e4%bb%a3%e7%a0%81%e6%ae%b5/9966451&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;代码段&lt;/a&gt;，可以是&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e8%b5%8b%e5%80%bc%e8%af%ad%e5%8f%a5/4248688&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;赋值语句&lt;/a&gt;或采集覆盖信息的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8/4127405&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;函数调用&lt;/a&gt;），通过&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e6%8e%a2%e9%92%88/1846154&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;探针&lt;/a&gt;的执行并抛出程序运行的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e7%89%b9%e5%be%81/6205236&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;特征&lt;/a&gt;数据，通过对这些数据的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e5%88%86%e6%9e%90/4327108&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;分析&lt;/a&gt;，可以获得程序的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e6%8e%a7%e5%88%b6%e6%b5%81/854473&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;控制流&lt;/a&gt;和数据流信息，进而得到&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e9%80%bb%e8%be%91%e8%a6%86%e7%9b%96/3231015&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;逻辑覆盖&lt;/a&gt;等动态信息，从而实现测试目的的方法。&lt;/p&gt;
&lt;p&gt;简单来说，程序插桩就是我们在调试程序时，常常要在程序中插入一些打印语句（想想我们在程序中常用的print语句），其目的是希望在程序执行中打印出我们最为关心的信息，然后进一步通过这些信息了解程序执行过程中程序的一些动态特性。&lt;/p&gt;
&lt;p&gt;从这一思想发展出程序插桩技术能够按照用户的要求，获取程序的各种信息，成为测试工作的有效测试手段。&lt;/p&gt;
&lt;h3 id=&#34;灰盒测试&#34;&gt;灰盒测试&lt;/h3&gt;
&lt;p&gt;根据利用的被测对象的信息不同，会采用不同的方法进行测试，一般的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用被测对象的整体特性信息，采用黑盒测试方法。&lt;/li&gt;
&lt;li&gt;利用被测对象的内部具体实现信息，采用白盒测试方法。&lt;/li&gt;
&lt;li&gt;如果既是利用被测对象的整体特性信息，又利用被测对象的内部具体实现信息，采用的就是灰盒测试方法。两种信息占比不同，相应的灰度就不同，完全是整体特性信息，就是黑盒测试，完全是内部具体实现信息，就是白盒测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;黑白灰盒测试方法总结&#34;&gt;黑、白、灰盒测试方法总结&lt;/h3&gt;
&lt;p&gt;我们一般从以下五个维度来区分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试阶段不同：
&lt;ul&gt;
&lt;li&gt;单元测试阶段主要利用白盒测试方法。&lt;/li&gt;
&lt;li&gt;集成测试阶段主要利用灰盒测试方法。&lt;/li&gt;
&lt;li&gt;系统测试阶段主要利用黑盒测试方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试依据，因为测试阶段的不同，采用的测试方法也不同，那它们的测试依据也不同：
&lt;ul&gt;
&lt;li&gt;白盒测试主要依据详细测试说明书（LLD）。&lt;/li&gt;
&lt;li&gt;黑盒测试主要依据需求规格（设计）说明书（SRS）。&lt;/li&gt;
&lt;li&gt;灰盒测试主要依据概要规格（设计）说明书（HLD）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试方法：
&lt;ul&gt;
&lt;li&gt;白盒测试方法可以有静态和动态，控制流、信息流、数据流、各种覆盖率、插桩处理。&lt;/li&gt;
&lt;li&gt;黑盒测试方法有各种测试类型（功能型、负载、恢复性），以及应用等价类、边界值、流程图法、正交法等。&lt;/li&gt;
&lt;li&gt;灰盒测试这里即用白盒的，也用黑盒的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;评估基准：
&lt;ul&gt;
&lt;li&gt;白盒根据逻辑覆盖率来评估。&lt;/li&gt;
&lt;li&gt;黑盒主要看需求规格的覆盖率。&lt;/li&gt;
&lt;li&gt;灰盒主要看接口覆盖率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点不一样：
&lt;ul&gt;
&lt;li&gt;白盒测试，特点是及早的发现问题，定位问题也很快，缺点是对接口、对设计、程序之间的调用、用户感受也不是很好。&lt;/li&gt;
&lt;li&gt;黑盒解决问题的代价比较大，很大发现模块内部的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;静态动态测试&#34;&gt;静态、动态测试&lt;/h2&gt;
&lt;p&gt;软件研发可以看成是一个生产过程，在此过程中会有产品输出或者称为工件输出。&lt;/p&gt;
&lt;p&gt;输出的产品可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最终产品，如变编译后的软件、用户手册等。&lt;/li&gt;
&lt;li&gt;中间产品，如SRS、HLD、LLD、源代码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是最终产品还是中间产品，都可以分成代码和文档。&lt;/p&gt;
&lt;p&gt;文档进一步细分还可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发文档，如SRS、HLD、LLD。&lt;/li&gt;
&lt;li&gt;测试文档，如测试计划、测试方案、测试用例等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要是软件产品，都是测试对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态测试和动态测试的划分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态测试，不运行被测对象，而是采用其他手段和技术对被测对象进行检测的一种测试技术。例如：代码走读、文档评审、程序分析都是静态测试的范畴，常用技术有静态分析技术。&lt;/p&gt;
&lt;p&gt;动态测试，按照预先设计的数据和步骤去运行被测对象，从而对被测对象进行检测的一种测试技术，常用技术有动态分析技术。&lt;/p&gt;
&lt;h3 id=&#34;静态测试&#34;&gt;静态测试&lt;/h3&gt;
&lt;p&gt;静态测试这里主要了解&lt;strong&gt;静态分析技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;**定义：**静态分析是一种不通过执行程序而分析程序执行的技术。&lt;/p&gt;
&lt;p&gt;**功能：**检查软件的表示和描述是否一致，没有冲突或者没有歧义，它的目标是纠正软件系统在描述、表示和规格上的错误，因此是任何进一步测试执行的前提。&lt;/p&gt;
&lt;p&gt;主要有三种不同的程序测试可能性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规格考虑，程序是否满足编码，语法上是否具有一致性和完整性。&lt;/li&gt;
&lt;li&gt;考虑文档描述是否规范、准确、是否便于查阅，例如描述是否不清楚、出现歧义等。&lt;/li&gt;
&lt;li&gt;考虑程序和文档之前的一致性，例如文档要求某文件大于1M抛出错误，而程序则是大于等于1M诸如此类的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态技术结构&#34;&gt;静态技术结构：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;手工静态分析——同行评审&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;正规检视，指定的人员参与、相关会议、相关文档都是比较正规的。&lt;/li&gt;
&lt;li&gt;技术评审。&lt;/li&gt;
&lt;li&gt;走查。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化静态分析&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态验证：&lt;/strong&gt;
检测规格到程序实现之间的转换上的问题，验证器需要有形式化的规格和规格的形式化定义，静态验证比较程序提供的设计值和在规格文档中被预先定义的目标值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语法分析器：&lt;/strong&gt;
是一个基本的自动化静态分析工具，它把程序/文档文本分解成独立的语句，当在内部检查程序/文本的时候，语句的一致性被进行了检查。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号执行器：&lt;/strong&gt;
在符号短语中分析一个程序在给定的路径上做了什么事情，它模拟程序的执行，计算在程序不同位置上变量的值，符号执行器非常适用于数学算法的分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态测试&#34;&gt;动态测试&lt;/h3&gt;
&lt;p&gt;**定义：**对软件系统运行行为进行分析，包含程序在受控的环境下使用特定的输入进行正式的运行，然后和期望的结果比较以检查系统运行时正确还是不正确。常用的动态分析技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径测试&lt;/li&gt;
&lt;li&gt;分支测试&lt;/li&gt;
&lt;li&gt;性能测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常用动态分析工具功能&#34;&gt;&lt;strong&gt;常用动态分析工具功能&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;动态分析类&lt;/th&gt;
&lt;th&gt;工具的功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;测试覆盖率分析&lt;/td&gt;
&lt;td&gt;测试对代码的检测范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跟踪&lt;/td&gt;
&lt;td&gt;跟踪程序执行期间的所有路径，例如所有变量的值等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调整&lt;/td&gt;
&lt;td&gt;度量程序执行过程中使用的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模拟&lt;/td&gt;
&lt;td&gt;模拟系统的一部分，例如无法获得的代码或者硬件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;断言检查&lt;/td&gt;
&lt;td&gt;测试在复杂逻辑结构中是否某个条件已被给出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;常用动态测试工具&#34;&gt;常用动态测试工具&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;QARun&lt;/li&gt;
&lt;li&gt;Robot&lt;/li&gt;
&lt;li&gt;QTP&lt;/li&gt;
&lt;li&gt;SikTest&lt;/li&gt;
&lt;li&gt;LoadRunner&lt;/li&gt;
&lt;li&gt;SilkPerformer&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;人工测试自动化测试&#34;&gt;人工测试、自动化测试&lt;/h2&gt;
&lt;p&gt;**人工测试：**测试活动（评审、测试设计、测试执行）由人来完成，狭义上是指测试执行由人工完成，这是最基本的测试形式。&lt;/p&gt;
&lt;p&gt;**自动化测试：**一般指通过计算机模拟人的测试行为，替代人的测试活动，狭义上是指测试执行由计算机来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化测试工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由HP提供的Quick Test Professional。&lt;/li&gt;
&lt;li&gt;Rational Robot，由IBM提供。&lt;/li&gt;
&lt;li&gt;Coded UI，由Microsoft提供。&lt;/li&gt;
&lt;li&gt;Selenium，开源软件。&lt;/li&gt;
&lt;li&gt;Auto It，开源软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;自动化测试的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照测试目的大致分为：功能自动化测试、性能自动化测试。&lt;/li&gt;
&lt;li&gt;按照测试对象可划分：web自动化测试、APP方向自动化测试、接口自动化测试、单元测试等。&lt;/li&gt;
&lt;li&gt;其他的包括代码测试和数据测试等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;自动化测试解决了哪些问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回归测试：项目在发布新版之后，对之前的功能进行验证。&lt;/li&gt;
&lt;li&gt;压力测试：统计软件服务器处理并发的能力，比如能支持多少个用户同时访问。&lt;/li&gt;
&lt;li&gt;兼容性测试：不同的系统平台，或者不同的浏览器。&lt;/li&gt;
&lt;li&gt;提高测试效率，保证了产品的质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;适合自动化测试的场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试任务明确，不会频繁变动。&lt;/li&gt;
&lt;li&gt;软件需求变更较少。&lt;/li&gt;
&lt;li&gt;项目周期长，测试脚本可以复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;自动化测试的限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能取代手工测试，自动化测试只能提高测试效率，不能提高测试有效性，即不可能发现更多缺陷。&lt;/li&gt;
&lt;li&gt;手工测试比自动化测试发现的缺陷更多。&lt;/li&gt;
&lt;li&gt;对测试设计依赖性极大，测试设计的不好会遗漏问题。&lt;/li&gt;
&lt;li&gt;自动化测试对软件开发具有很大的依赖性，开发上出现变更可能导致前面的自动化测试完全失效。&lt;/li&gt;
&lt;li&gt;工具本身并不具备想象力。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>使用Docker部署Go的web应用</title>
        <link>https://kingsqiu.github.io/p/docker-goweb/</link>
        <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/docker-goweb/</guid>
        <description>&lt;h2 id=&#34;docker的必要性&#34;&gt;Docker的必要性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：在本地开发应用程序后，有很多的依赖环境或包，甚至对依赖的具体版本都有严格的要求。当开发过程完成后，若希望将应用程序部署到web服务器。这个时候必须确保所有依赖项都安装正确并且版本也完全相同，否则应用程序可能会崩溃并无法运行。如果想在另一个web服务器上也部署该应用程序，那么必须从头开始重复这个过程。这种场景就是Docker发挥作用的地方。&lt;/p&gt;
&lt;p&gt;对于运行应用程序的主机，不管是笔记本电脑还是web服务器，唯一需要做的就是运行一个docker容器平台。从以后，就不需要担心使用的是MacOS，Ubuntu，Arch还是其他。只需定义一次应用，即可随时随地运行。&lt;/p&gt;
&lt;h2 id=&#34;docker部署示例&#34;&gt;Docker部署示例&lt;/h2&gt;
&lt;h3 id=&#34;创建docker镜像&#34;&gt;创建Docker镜像&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;镜像（image）包含运行应用程序所需的所有东西——代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者简单地说，镜像（image）是定义应用程序及其运行所需的一切。&lt;/p&gt;
&lt;h3 id=&#34;编写dockerfile&#34;&gt;编写Dockerfile&lt;/h3&gt;
&lt;p&gt;要创建Docker镜像（image）必须在配置文件中指定步骤。这个文件默认为&lt;code&gt;Dockerfile&lt;/code&gt;。（虽然这个文件名可以随意命名它，但最好还是使用默认的&lt;code&gt;Dockerfile&lt;/code&gt;。）&lt;/p&gt;
&lt;p&gt;具体内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; golang:alpine&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 为我们的镜像设置必要的环境变量&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GO111MODULE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;on &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;CGO_ENABLED&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOOS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;linux &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;amd64

&lt;span class=&#34;c&#34;&gt;# 移动到工作目录：/build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将代码复制到容器中&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将我们的代码编译成二进制可执行文件app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; go build -o app .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 移动到用于存放生成的二进制文件的 /dist 目录&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /dist&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将二进制文件从 /build 目录复制到这里&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; cp /build/app .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 声明服务端口&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;EXPOSE&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; 8888&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 启动容器时运行的命令&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/dist/app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;dockerfile解析&#34;&gt;Dockerfile解析&lt;/h4&gt;
&lt;p&gt;官方文档：https://hub.docker.com/_/golang&lt;/p&gt;
&lt;p&gt;**From：**这里使用基础镜像&lt;code&gt;golang:alpine&lt;/code&gt;。是一个我们能够访问的存储在Docker仓库的基础镜像。这个镜像运行的是alpine Linux发行版，该发行版的大小很小并且内置了Go。&lt;/p&gt;
&lt;p&gt;**Env：**用来设置编译阶段需要用的环境变量。&lt;/p&gt;
&lt;p&gt;**EXPORT，CMD：**最后，声明服务端口，因为应用程序监听的是这个端口并通过这个端口对外提供服务。并且我们还定义了在我们运行镜像的时候默认执行的命令&lt;code&gt;CMD [&amp;quot;/dist/app&amp;quot;]&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;构建镜像&#34;&gt;构建镜像&lt;/h3&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HandleFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;:8888&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server startup...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server startup failed, err:%v\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello world&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在项目目录下，执行下面的命令创建镜像，并指定镜像名称为&lt;code&gt;goweb_app&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker build . -t goweb_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待构建过程结束，输出如下提示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;...
Successfully built 90d9283286b7
Successfully tagged goweb_app:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们已经准备好了镜像，但是目前它什么也没做。我们接下来要做的是运行我们的镜像，以便它能够处理我们的请求。运行中的镜像称为容器。&lt;/p&gt;
&lt;p&gt;执行下面的命令来运行镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -p 8888:8888 goweb_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标志位&lt;code&gt;-p&lt;/code&gt;用来定义端口绑定。由于容器中的应用程序在端口8888上运行，我们将其绑定到主机端口也是8888。如果要绑定到另一个端口，则可以使用&lt;code&gt;-p $HOST_PORT:8888&lt;/code&gt;。例如&lt;code&gt;-p 5000:8888&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在就可以测试下我们的web程序是否工作正常，打开浏览器输入&lt;code&gt;http://127.0.0.1:8888&lt;/code&gt;就能看到我们事先定义的响应内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hello world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;分阶段构建示例&#34;&gt;分阶段构建示例&lt;/h2&gt;
&lt;p&gt;Go程序编译之后会得到一个可执行的二进制文件，其实在最终的镜像中是不需要go编译器的，也就是说我们只需要一个运行最终二进制文件的容器即可。&lt;/p&gt;
&lt;p&gt;Docker的最佳实践之一是通过仅保留二进制文件来减小镜像大小，为此这里使用一种称为多阶段构建的技术，这意味着我们将通过多个步骤构建镜像。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; golang:alpine AS builder&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 为我们的镜像设置必要的环境变量&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GO111MODULE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;on &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;CGO_ENABLED&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOOS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;linux &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;amd64

&lt;span class=&#34;c&#34;&gt;# 移动到工作目录：/build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将代码复制到容器中&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将我们的代码编译成二进制可执行文件 app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; go build -o app .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;###################&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 接下来创建一个小镜像&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;###################&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 从builder镜像中把/dist/app 拷贝到当前目录&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;builder /build/app /&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 需要运行的命令&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENTRYPOINT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这种技术，剥离了使用&lt;code&gt;golang:alpine&lt;/code&gt;作为编译镜像来编译得到二进制可执行文件的过程，并基于&lt;code&gt;scratch&lt;/code&gt;生成一个简单的、非常小的新镜像。将二进制文件从命名为&lt;code&gt;builder&lt;/code&gt;的第一个镜像中复制到新创建的&lt;code&gt;scratch&lt;/code&gt;镜像中。&lt;/p&gt;
&lt;p&gt;有关scratch镜像的更多信息，查看https://hub.docker.com/_/scratch&lt;/p&gt;
</description>
        </item>
        <item>
        <title>hugo博客使用笔记</title>
        <link>https://kingsqiu.github.io/p/hugo-blog-use/</link>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/hugo-blog-use/</guid>
        <description>&lt;p&gt;关于是怎么了解到hugo的已经被忘记了，就记得hugo比hexo好用，然后就开始用了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>文章配置</title>
        <link>https://kingsqiu.github.io/p/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/</guid>
        <description>&lt;img src="https://kingsqiu.github.io/p/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/screenshot.png" alt="Featured image of post 文章配置" /&gt;&lt;h3 id=&#34;配置变量说明官网链接&#34;&gt;配置变量说明官网链接：&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/content-management/front-matter/#front-matter-variables&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Front Matter Variables&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;模板&#34;&gt;模板&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;YAML&lt;/strong&gt;, identified by ‘&lt;code&gt;---&lt;/code&gt;’.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;---
author: 
title: 
description: 
date: 2020-00-00
slug: 
image: 
categories:
    - 
tags: 
    - 
---
（四个空格，不要用两个tab）
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TOML&lt;/strong&gt;, identified by ‘&lt;code&gt;+++&lt;/code&gt;’.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;+++
author = &amp;quot;&amp;quot;
title = &amp;quot;&amp;quot;
description = &amp;quot;&amp;quot;
date = &amp;quot;2020-00-00&amp;quot;
slug = &amp;quot;&amp;quot;
image = &amp;quot;&amp;quot;
categories = [
    &amp;quot;&amp;quot;
]
tags = [
    &amp;quot;&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JSON&lt;/strong&gt;, a single JSON object which is surrounded by ‘&lt;code&gt;{&lt;/code&gt;’ and ‘&lt;code&gt;}&lt;/code&gt;’, each on their own line.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;title&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;date&amp;quot;: &amp;quot;2020-00-00&amp;quot;
    &amp;quot;slug&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;image&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;categories&amp;quot;: [
        &amp;quot;&amp;quot;
    ]
    &amp;quot;tags&amp;quot;: [
        &amp;quot;&amp;quot;
    ]    
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
    </channel>
</rss>
