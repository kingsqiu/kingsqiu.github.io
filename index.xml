<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>盒木</title>
        <link>https://kingsqiu.github.io/</link>
        <description>Recent content on 盒木</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 11 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://kingsqiu.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>B站直播教程</title>
        <link>https://kingsqiu.github.io/p/coffee-machine/</link>
        <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/coffee-machine/</guid>
        <description>&lt;p&gt;直播软件：&lt;/p&gt;
&lt;p&gt;直播间美化平台：&lt;/p&gt;
&lt;p&gt;虚拟偶像动捕设备和软件：&lt;/p&gt;
</description>
        </item>
        <item>
        <title>咖啡机的原理</title>
        <link>https://kingsqiu.github.io/p/coffee-machine/</link>
        <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/coffee-machine/</guid>
        <description></description>
        </item>
        <item>
        <title>常见的黑盒测试方法</title>
        <link>https://kingsqiu.github.io/p/black_box/</link>
        <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/black_box/</guid>
        <description>&lt;p&gt;编写测试用例，都有哪些可以参考的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求文档&lt;/li&gt;
&lt;li&gt;积极与开发、产品、客户进行沟通&lt;/li&gt;
&lt;li&gt;开发（设计）文档，当然，有可能也拿不到，比如说开发和测试分属不同的公司，人家开发就不一定提供文档。&lt;/li&gt;
&lt;li&gt;被测系统（已经开发出来的被测系统），一边对照程序，一边编写用例，很多企业都采用这种方式，如果只对照需求文档可能仅能完成测试的30~40%。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编写黑盒测试用例的时候，我们可以有以下几种形式来完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等价类划分法&lt;/li&gt;
&lt;li&gt;边界值法&lt;/li&gt;
&lt;li&gt;场景法&lt;/li&gt;
&lt;li&gt;因果图法&lt;/li&gt;
&lt;li&gt;判定表法&lt;/li&gt;
&lt;li&gt;正交（排列）法&lt;/li&gt;
&lt;li&gt;测试大纲法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等价类划分法&#34;&gt;等价类划分法&lt;/h2&gt;
&lt;p&gt;等价类划分法是一种重要的、常用的黑盒测试方法，无需考虑程序的内部结构，只需要考虑程序的输入规格即可，它将不能穷举的测试过程进行合理的分类，划分为了若干份（或称为不同的子集），然后从每个子集中&lt;strong&gt;选取少数具有代表性的数据作为测试用例&lt;/strong&gt;从而保证设计出来的测试用例具有完整性和代表性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等价类划分分为（基本概念）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有效等价类，指符合《需求规格说明书》，输入合理的数据集合。&lt;/li&gt;
&lt;li&gt;无效等价类，指不符合《需求规格说明书》，输入不合理的数据集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;等价类思考步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先确定有效等价类和无效等价类&lt;/li&gt;
&lt;li&gt;有效等价类就是一目了然的题目条件（比如在0~20之间测试），要考虑到两端的极值（边界值）和中间值。&lt;/li&gt;
&lt;li&gt;无效等价类先划分与条件相反的情况（比如不在0~20范围内），再去找特殊情况，如中英文，符号、空格、空等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;等价类划分发的测试思想&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;穷举测试：把所有可能的数据全部测试一遍称为穷举测试，虽然穷举测试是最全面的测试，但是很明显不现实，因为测试效率太低了，数据量巨大，根本测不过来（思考前面计算器的例子）。但又因为没有做过穷举测试，所以会有遗漏缺陷的风险，如果时间允许，尽可能的做补充测试（觉得有风险有问题的做补充测试）。&lt;/li&gt;
&lt;li&gt;理想的测试思想，使用最少的测试数据，达到最好的测试质量。&lt;/li&gt;
&lt;li&gt;而等价类划分法则是从大量的数据中，划分范围（或分类），每个范围内的数据测试效果是等价的，所以每个范围是一个等价类，然后从每个范围内挑选出具有代表性的数据，这些代表数据能反映这个范围内的测试结果。&lt;/li&gt;
&lt;li&gt;等价类划分法的基本思想是：
&lt;ul&gt;
&lt;li&gt;有效等价类，对于程序来说，是有意义的，合理的输入数据集合，然后测试功能是否符合预期。&lt;/li&gt;
&lt;li&gt;无效等价类，对于程序来说，是无意义的，不合理的输入数据集，用来测试程序是否具有强大的异常处理能力，也就是测试程序的健壮性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;边界值法&#34;&gt;边界值法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是边界值？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;边界是指对于输入等价类和输出等价类而言，稍高于边界值和稍低于边界值的一些特定情况，边界值分析法常应用于黑盒测试中。边界值也可以称为极值。&lt;/p&gt;
&lt;p&gt;根据以往的经验来看：&lt;strong&gt;大量的错误是发生在输入或者输出范围的边界上，而不是再输入范围的内部&lt;/strong&gt;。所以，为了保证测试质量，我们需要重点关注测试边界。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效数据和无效数据的分界点，往往作为程序员编写程序的判断点，所以，这也是程序员最容易犯错的地方（他很有可能听着歌，脑子里想着是大于小于，结果手比脑子动的快，写成小于等于等等情况），所以，边界值这里是我们测试人员重点测试的地方&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么如何解决这类问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到测试数据的边界点，也就是有效等价类和无效等价类的边界点，对于边界点数据专门进行测试。&lt;/li&gt;
&lt;li&gt;一般的，测试人员需要对边界值及边界值两边的数分别进行测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;确定边界值的一般思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定边界情况，也就是确定输入或者输出等价类的边界&lt;/li&gt;
&lt;li&gt;选取正好等于、刚刚大于、刚刚小于边界值作为测试数据&lt;/li&gt;
&lt;li&gt;边界值的取值依据输入范围区间不同而有所不同，但是都需要把上点值、离点值、和内点值取到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;边界值的方法思考：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果输入条件规定了范围，则应该取这个范围的边界值，比如&lt;code&gt;1~100&lt;/code&gt;，边界值应该取&lt;code&gt;0 1 100 101&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果输入条件规定了输入值的个数。比如密码长度为&lt;code&gt;8~24&lt;/code&gt;，边界值应该取&lt;code&gt;7 8 9 23 24 25&lt;/code&gt;位字符来判断。&lt;/li&gt;
&lt;li&gt;边界值和等价类的区别，边界值分析不是从等价类中随便找一个作为代表，而是整个等价类的每个边界都要作为测试条件。&lt;/li&gt;
&lt;li&gt;边界值的思想是在结合实际环境，应该选出到边界和刚超过的值作为测试依据。边界值和等价类是相辅相成的，共同使测试用例更加完善。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的边界值：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环中的第1、2次和倒数第1、2次。&lt;/li&gt;
&lt;li&gt;数值元素的第一个和最后一个值。&lt;/li&gt;
&lt;li&gt;报表的第一行和最后一行。&lt;/li&gt;
&lt;li&gt;文本框接收字符个数，用户名长度啊，密码长度等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;场景法&#34;&gt;场景法&lt;/h2&gt;
&lt;p&gt;场景法就是模拟用户操作软件时的场景，主要用于测试系统的业务流程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当接到一个测试任务时，我们并不关注某个控制的边界值，等价类是否满足要求。而是要关注它的主要功能和业务流程是否正确实现，这就需要使用场景法来完成测试。&lt;/li&gt;
&lt;li&gt;当业务流程没问题时，即软件的主要功能没有问题时，我们再重新从边界值、等价类方面对软件进行测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在冒烟测试时也主要采用场景法进行测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用例场景定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在场景法中有两个重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本流：按照正确的业务流程来实现一条操作路径，即模拟正确的操作流程。&lt;/li&gt;
&lt;li&gt;备选流：导致程序出现错误的操作流程，即模拟错误的操作流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用例场景使用来描述流经用例路径的过程，这个过程从开始到结束遍历用例中所有的基本流和备选流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用例场景产生的背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在的软件几乎都是由事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件因不同的触发顺序和处理结果形成事件流。&lt;/p&gt;
&lt;p&gt;将这种在软件设计方面的思想引入到软件测试中，生动的描绘出时间触发时的情景，有利于测试设计者测试用例，同时测试用例也更容易得到理解和执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在使用场景法设计测试用例时，需要覆盖系统用例中的主&lt;strong&gt;成功场景&lt;/strong&gt;和&lt;strong&gt;扩展场景&lt;/strong&gt;。并且需要适当补充各种正反面的测试用例和考虑出异常场景的情形。&lt;/li&gt;
&lt;li&gt;当使用场景测试软件没有问题时，可以再使用边界值、等价类划分法等测试方法对软件进行更加细致、完整的测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;流程分析法&#34;&gt;流程分析法&lt;/h3&gt;
&lt;p&gt;流程分析法主要是针对测试场景类型，属于流程测试场景的测试项下的一个测试子项进行设计。是从白盒测试设计方法中的路径覆盖分析法借鉴过来的一种方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在白盒测试中，路径就是指函数代码的某个分支组合，路径覆盖法需要构造足够的用例，以覆盖函数的所有代码路径。&lt;/li&gt;
&lt;li&gt;在黑盒测试中，若将软件系统的某个流程看成路径的话，则可以针对该路径使用路径分析法设计测试用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低了测试用例的设计难度，只要搞清楚各种流程，就可以设计出高质量的测试用例来，而不需要太多测试方面的经验。&lt;/li&gt;
&lt;li&gt;在测试时间较为紧迫的情况下，可以有的放矢的选择测试用例，而不用完全根据经验来取舍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;流程分析法的实施步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;详细了解需求。&lt;/li&gt;
&lt;li&gt;根据需求说明或界面原型，找出业务流程的各个页面以及各个页面之间的流转关系。&lt;/li&gt;
&lt;li&gt;画出业务流程，由产品经理使用Axure软件制作。&lt;/li&gt;
&lt;li&gt;写用例，覆盖所有的路径分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;因果图法&#34;&gt;因果图法&lt;/h2&gt;
&lt;p&gt;因果图（Cause-Effect Graph）法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适用于检查程序输入条件的各种组合情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因果图法产生的背景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等价类划分法和边界值分析方法都是着重的考虑输入条件，但是极少的考虑输入条件的各种组合、输入条件之间的相互制约关系，这样虽然各种输入条件可能出错的情况已经测试到了，但是多个输入条件组合起来可能出错的情况却很难发现。&lt;/li&gt;
&lt;li&gt;如果在测试的时候，必须考虑输入条件的组合情况，那么可能的组合情况将非常的多，导致测试任务繁重。因此，我们必须考虑一种适合于描述多种条件的组合，相应产生多个动作的形式来进行测试用例的设计，这就用到了因果图，也就是设计逻辑模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因果图的核心&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因果图之&lt;code&gt;因&lt;/code&gt;，即输入条件。&lt;/li&gt;
&lt;li&gt;因果图之&lt;code&gt;果&lt;/code&gt;，即输出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因果图法的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑输入条件的相互制约及组合关系&lt;/li&gt;
&lt;li&gt;考虑输出条件对输入条件的依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因果图法要注意考虑的要点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有输入/输出条件的相互制约关系及组合关系。&lt;/li&gt;
&lt;li&gt;输出结果对输入条件的依赖关系，也就是什么样的输入组合会产生怎样的输出结果，即&lt;code&gt;因果关系&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因果图中的约束条件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥：最多有一个可能成立&lt;/li&gt;
&lt;li&gt;包含：至少有一个必须成立&lt;/li&gt;
&lt;li&gt;唯一：多个原因中只能有一个成立&lt;/li&gt;
&lt;li&gt;屏蔽：a成立，b不成立；a不成立，b不确定&lt;/li&gt;
&lt;li&gt;要求：一个出现，另一个一定出现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因果图法导出测试用例基本步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找出所有的原因，原因即是输入条件或输入条件的等价类。&lt;/li&gt;
&lt;li&gt;找出所有的结果，结果即输出条件。&lt;/li&gt;
&lt;li&gt;明确所有输入条件之间的制约关系及组合关系。比如，哪些条件可以组合到一起，哪些条件不能组合到一起。&lt;/li&gt;
&lt;li&gt;明确所有输出条件之间的制约关系以及组合关系。比如，哪些输出结果可以同时输出，哪些输出结果不能同时输出。&lt;/li&gt;
&lt;li&gt;找出什么样的输入条件组合会产生哪种输出结果。&lt;/li&gt;
&lt;li&gt;把因果图转换成判定表/决策表。&lt;/li&gt;
&lt;li&gt;为判定表/决策表中的每一列表示的情况设计测试用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;判定表法&#34;&gt;判定表法&lt;/h2&gt;
&lt;p&gt;因果图只是一种辅助工具，我们通过因果图分析出一个表，这个表就是判定表，然后通过判定表编写测试用例。但是有的时候，画因果图非常麻烦，影响测试效率，所以，我们很多时候都是直接写判定表，进而编写测试用例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定表的组成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件桩：问题的所有条件，即所有的条件组合。&lt;/li&gt;
&lt;li&gt;动作桩：问题的所有输出，即所有的输出组合。&lt;/li&gt;
&lt;li&gt;条件项：针对条件桩的取值。&lt;/li&gt;
&lt;li&gt;动作项：条件项的各种取值情况下的输出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判定表制作步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出所有的条件桩和动作桩。&lt;/li&gt;
&lt;li&gt;填入条件项与动作项，得到初始判定表。&lt;/li&gt;
&lt;li&gt;简化判定表（合并相似规则（相同动作））。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;正交排列法&#34;&gt;正交（排列）法&lt;/h2&gt;
&lt;p&gt;在测试时，由于组合量太大，不可能为每一种组合都创建测试用例。如何采用最少的测试用例集合获得最大的测试覆盖率——采用&lt;strong&gt;正交排列法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正交测试法中比较重要的两个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因素（Factor）：在一项实验中，凡欲考察的变量称为因素（变量）。&lt;/li&gt;
&lt;li&gt;水平（位级，Level）：在实验范围内，因素被考察的值称为水平（变量的取值）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正交表&#34;&gt;&lt;strong&gt;正交表&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;正交表是一个二维表格，它的构成如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行数（Runs）：正交表中行的个数，即实验的次数（用例）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因素数（Factors）：正交表中列的个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;水平数（Levels）：任何单个因素能够取得的值的最大个数。正交表中包含的值为从0到&lt;strong&gt;水平数减一&lt;/strong&gt;或&lt;strong&gt;从1到水平数&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正交表的的表示形式：
$$
𝐿_n(m^k)
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n是表的行数，也就是需要测试组合的次数&lt;/li&gt;
&lt;li&gt;k是表的列数，表示控件的个数（因素数或因子数）&lt;/li&gt;
&lt;li&gt;m是每个控件包含的取值个数（各因素的水平数，即各因素的状态数）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>测试基础方法</title>
        <link>https://kingsqiu.github.io/p/test-ways/</link>
        <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/test-ways/</guid>
        <description>&lt;h2 id=&#34;黒白灰盒测试&#34;&gt;黒、白、灰盒测试&lt;/h2&gt;
&lt;h3 id=&#34;黑盒测试&#34;&gt;黑盒测试&lt;/h3&gt;
&lt;p&gt;黑盒测试把被测对象看成一个黑匣子，只考虑期整体的特性，不考虑期内部具体实现。&lt;/p&gt;
&lt;p&gt;黑盒测试的被测对象可以是一个系统、一个子系统、一模块、子模块、一个函数等。&lt;/p&gt;
&lt;p&gt;黑盒测试又可以被称为基于规格的测试。&lt;/p&gt;
&lt;h4 id=&#34;常见的黑盒测试类型&#34;&gt;&lt;strong&gt;常见的黑盒测试类型&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;功能性测试
&lt;ul&gt;
&lt;li&gt;一种是顺序测试每个程序特性或功能；&lt;/li&gt;
&lt;li&gt;另一种是一个模块一个模块的测试，即每个功能在其最先调用的地方被测试；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容量测试，检测软件在处理海量数据时的局限性，能发现系统效率方面的问题。&lt;/li&gt;
&lt;li&gt;负载测试，检测系统在短时间内处理巨大的数据量或执行许多功能调用上的能力。&lt;/li&gt;
&lt;li&gt;恢复性测试，主要保证系统在崩溃后能回复外部数据的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;白盒测试&#34;&gt;白盒测试&lt;/h3&gt;
&lt;p&gt;白盒测试是依据被测软件分析程序内部构造，并根据内部构造设计用例，来对内部控制流程进行测试，可完全不顾程序的整体功能实现情况。&lt;/p&gt;
&lt;p&gt;白盒测试是基于程序结构的逻辑驱动测试。&lt;/p&gt;
&lt;p&gt;白盒测试又可以被称为玻璃盒测试、透明盒测试、开放盒测试、结构化测试、逻辑驱动测试。&lt;/p&gt;
&lt;p&gt;白盒测试一般在测试前期进行，通过达到一定的逻辑覆盖率指标，使得软件内部逻辑控制结构上的问题能基本得到解决。&lt;/p&gt;
&lt;p&gt;白盒测试能保证内部逻辑结构能达到一定的覆盖程度，能够给予软件代码质量更大的保证。&lt;/p&gt;
&lt;p&gt;白盒测试发现问题后解决问题的成本较低，毕竟介入的早嘛。&lt;/p&gt;
&lt;p&gt;白盒测试一般会用到静态分析和动态分析两类技术，常用的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态分析：控制流分析、数据流分析、信息流分析；&lt;/li&gt;
&lt;li&gt;动态分析：逻辑覆盖测试（分支测试、路径测试等）、程序插桩等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;白盒测试的特点&#34;&gt;&lt;strong&gt;白盒测试的特点&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;测试人员需要了解软件的实现；&lt;/li&gt;
&lt;li&gt;可以检测代码中的每一条分支和路径；&lt;/li&gt;
&lt;li&gt;揭示隐藏在代码代码中的错误；&lt;/li&gt;
&lt;li&gt;对代码的测试相对彻底；&lt;/li&gt;
&lt;li&gt;实现代码结构上的优化；&lt;/li&gt;
&lt;li&gt;白盒测试的投入较大，成本高；&lt;/li&gt;
&lt;li&gt;白盒测试不验证（需求）规格的正确性；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;逻辑覆盖率测试&#34;&gt;&lt;strong&gt;逻辑覆盖率测试&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;根据覆盖的对象不同，存在多种逻辑覆盖测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语句覆盖；&lt;/li&gt;
&lt;li&gt;判定覆盖；&lt;/li&gt;
&lt;li&gt;条件覆盖；&lt;/li&gt;
&lt;li&gt;判定-条件覆盖；&lt;/li&gt;
&lt;li&gt;路径覆盖；&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而逻辑覆盖率的统计是通过&lt;strong&gt;程序插桩&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序插桩：&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e7%a8%8b%e5%ba%8f%e6%8f%92%e6%a1%a9&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程序插桩&lt;/a&gt;，最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e6%8e%a2%e9%92%88/1846154&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;探针&lt;/a&gt;（又称为“探测仪”，本质上就是进行信息采集的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e4%bb%a3%e7%a0%81%e6%ae%b5/9966451&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;代码段&lt;/a&gt;，可以是&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e8%b5%8b%e5%80%bc%e8%af%ad%e5%8f%a5/4248688&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;赋值语句&lt;/a&gt;或采集覆盖信息的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8/4127405&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;函数调用&lt;/a&gt;），通过&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e6%8e%a2%e9%92%88/1846154&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;探针&lt;/a&gt;的执行并抛出程序运行的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e7%89%b9%e5%be%81/6205236&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;特征&lt;/a&gt;数据，通过对这些数据的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e5%88%86%e6%9e%90/4327108&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;分析&lt;/a&gt;，可以获得程序的&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e6%8e%a7%e5%88%b6%e6%b5%81/854473&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;控制流&lt;/a&gt;和数据流信息，进而得到&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%e9%80%bb%e8%be%91%e8%a6%86%e7%9b%96/3231015&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;逻辑覆盖&lt;/a&gt;等动态信息，从而实现测试目的的方法。&lt;/p&gt;
&lt;p&gt;简单来说，程序插桩就是我们在调试程序时，常常要在程序中插入一些打印语句（想想我们在程序中常用的print语句），其目的是希望在程序执行中打印出我们最为关心的信息，然后进一步通过这些信息了解程序执行过程中程序的一些动态特性。&lt;/p&gt;
&lt;p&gt;从这一思想发展出程序插桩技术能够按照用户的要求，获取程序的各种信息，成为测试工作的有效测试手段。&lt;/p&gt;
&lt;h3 id=&#34;灰盒测试&#34;&gt;灰盒测试&lt;/h3&gt;
&lt;p&gt;根据利用的被测对象的信息不同，会采用不同的方法进行测试，一般的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用被测对象的整体特性信息，采用黑盒测试方法。&lt;/li&gt;
&lt;li&gt;利用被测对象的内部具体实现信息，采用白盒测试方法。&lt;/li&gt;
&lt;li&gt;如果既是利用被测对象的整体特性信息，又利用被测对象的内部具体实现信息，采用的就是灰盒测试方法。两种信息占比不同，相应的灰度就不同，完全是整体特性信息，就是黑盒测试，完全是内部具体实现信息，就是白盒测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;黑白灰盒测试方法总结&#34;&gt;黑、白、灰盒测试方法总结&lt;/h3&gt;
&lt;p&gt;我们一般从以下五个维度来区分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试阶段不同：
&lt;ul&gt;
&lt;li&gt;单元测试阶段主要利用白盒测试方法。&lt;/li&gt;
&lt;li&gt;集成测试阶段主要利用灰盒测试方法。&lt;/li&gt;
&lt;li&gt;系统测试阶段主要利用黑盒测试方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试依据，因为测试阶段的不同，采用的测试方法也不同，那它们的测试依据也不同：
&lt;ul&gt;
&lt;li&gt;白盒测试主要依据详细测试说明书（LLD）。&lt;/li&gt;
&lt;li&gt;黑盒测试主要依据需求规格（设计）说明书（SRS）。&lt;/li&gt;
&lt;li&gt;灰盒测试主要依据概要规格（设计）说明书（HLD）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试方法：
&lt;ul&gt;
&lt;li&gt;白盒测试方法可以有静态和动态，控制流、信息流、数据流、各种覆盖率、插桩处理。&lt;/li&gt;
&lt;li&gt;黑盒测试方法有各种测试类型（功能型、负载、恢复性），以及应用等价类、边界值、流程图法、正交法等。&lt;/li&gt;
&lt;li&gt;灰盒测试这里即用白盒的，也用黑盒的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;评估基准：
&lt;ul&gt;
&lt;li&gt;白盒根据逻辑覆盖率来评估。&lt;/li&gt;
&lt;li&gt;黑盒主要看需求规格的覆盖率。&lt;/li&gt;
&lt;li&gt;灰盒主要看接口覆盖率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点不一样：
&lt;ul&gt;
&lt;li&gt;白盒测试，特点是及早的发现问题，定位问题也很快，缺点是对接口、对设计、程序之间的调用、用户感受也不是很好。&lt;/li&gt;
&lt;li&gt;黑盒解决问题的代价比较大，很大发现模块内部的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;静态动态测试&#34;&gt;静态、动态测试&lt;/h2&gt;
&lt;p&gt;软件研发可以看成是一个生产过程，在此过程中会有产品输出或者称为工件输出。&lt;/p&gt;
&lt;p&gt;输出的产品可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最终产品，如变编译后的软件、用户手册等。&lt;/li&gt;
&lt;li&gt;中间产品，如SRS、HLD、LLD、源代码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是最终产品还是中间产品，都可以分成代码和文档。&lt;/p&gt;
&lt;p&gt;文档进一步细分还可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发文档，如SRS、HLD、LLD。&lt;/li&gt;
&lt;li&gt;测试文档，如测试计划、测试方案、测试用例等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要是软件产品，都是测试对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态测试和动态测试的划分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态测试，不运行被测对象，而是采用其他手段和技术对被测对象进行检测的一种测试技术。例如：代码走读、文档评审、程序分析都是静态测试的范畴，常用技术有静态分析技术。&lt;/p&gt;
&lt;p&gt;动态测试，按照预先设计的数据和步骤去运行被测对象，从而对被测对象进行检测的一种测试技术，常用技术有动态分析技术。&lt;/p&gt;
&lt;h3 id=&#34;静态测试&#34;&gt;静态测试&lt;/h3&gt;
&lt;p&gt;静态测试这里主要了解&lt;strong&gt;静态分析技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;**定义：**静态分析是一种不通过执行程序而分析程序执行的技术。&lt;/p&gt;
&lt;p&gt;**功能：**检查软件的表示和描述是否一致，没有冲突或者没有歧义，它的目标是纠正软件系统在描述、表示和规格上的错误，因此是任何进一步测试执行的前提。&lt;/p&gt;
&lt;p&gt;主要有三种不同的程序测试可能性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规格考虑，程序是否满足编码，语法上是否具有一致性和完整性。&lt;/li&gt;
&lt;li&gt;考虑文档描述是否规范、准确、是否便于查阅，例如描述是否不清楚、出现歧义等。&lt;/li&gt;
&lt;li&gt;考虑程序和文档之前的一致性，例如文档要求某文件大于1M抛出错误，而程序则是大于等于1M诸如此类的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态技术结构&#34;&gt;静态技术结构：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;手工静态分析——同行评审&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;正规检视，指定的人员参与、相关会议、相关文档都是比较正规的。&lt;/li&gt;
&lt;li&gt;技术评审。&lt;/li&gt;
&lt;li&gt;走查。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化静态分析&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态验证：&lt;/strong&gt;
检测规格到程序实现之间的转换上的问题，验证器需要有形式化的规格和规格的形式化定义，静态验证比较程序提供的设计值和在规格文档中被预先定义的目标值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语法分析器：&lt;/strong&gt;
是一个基本的自动化静态分析工具，它把程序/文档文本分解成独立的语句，当在内部检查程序/文本的时候，语句的一致性被进行了检查。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号执行器：&lt;/strong&gt;
在符号短语中分析一个程序在给定的路径上做了什么事情，它模拟程序的执行，计算在程序不同位置上变量的值，符号执行器非常适用于数学算法的分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态测试&#34;&gt;动态测试&lt;/h3&gt;
&lt;p&gt;**定义：**对软件系统运行行为进行分析，包含程序在受控的环境下使用特定的输入进行正式的运行，然后和期望的结果比较以检查系统运行时正确还是不正确。常用的动态分析技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径测试&lt;/li&gt;
&lt;li&gt;分支测试&lt;/li&gt;
&lt;li&gt;性能测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常用动态分析工具功能&#34;&gt;&lt;strong&gt;常用动态分析工具功能&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;动态分析类&lt;/th&gt;
&lt;th&gt;工具的功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;测试覆盖率分析&lt;/td&gt;
&lt;td&gt;测试对代码的检测范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跟踪&lt;/td&gt;
&lt;td&gt;跟踪程序执行期间的所有路径，例如所有变量的值等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调整&lt;/td&gt;
&lt;td&gt;度量程序执行过程中使用的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模拟&lt;/td&gt;
&lt;td&gt;模拟系统的一部分，例如无法获得的代码或者硬件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;断言检查&lt;/td&gt;
&lt;td&gt;测试在复杂逻辑结构中是否某个条件已被给出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;常用动态测试工具&#34;&gt;常用动态测试工具&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;QARun&lt;/li&gt;
&lt;li&gt;Robot&lt;/li&gt;
&lt;li&gt;QTP&lt;/li&gt;
&lt;li&gt;SikTest&lt;/li&gt;
&lt;li&gt;LoadRunner&lt;/li&gt;
&lt;li&gt;SilkPerformer&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;人工测试自动化测试&#34;&gt;人工测试、自动化测试&lt;/h2&gt;
&lt;p&gt;**人工测试：**测试活动（评审、测试设计、测试执行）由人来完成，狭义上是指测试执行由人工完成，这是最基本的测试形式。&lt;/p&gt;
&lt;p&gt;**自动化测试：**一般指通过计算机模拟人的测试行为，替代人的测试活动，狭义上是指测试执行由计算机来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化测试工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由HP提供的Quick Test Professional。&lt;/li&gt;
&lt;li&gt;Rational Robot，由IBM提供。&lt;/li&gt;
&lt;li&gt;Coded UI，由Microsoft提供。&lt;/li&gt;
&lt;li&gt;Selenium，开源软件。&lt;/li&gt;
&lt;li&gt;Auto It，开源软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;自动化测试的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照测试目的大致分为：功能自动化测试、性能自动化测试。&lt;/li&gt;
&lt;li&gt;按照测试对象可划分：web自动化测试、APP方向自动化测试、接口自动化测试、单元测试等。&lt;/li&gt;
&lt;li&gt;其他的包括代码测试和数据测试等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;自动化测试解决了哪些问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回归测试：项目在发布新版之后，对之前的功能进行验证。&lt;/li&gt;
&lt;li&gt;压力测试：统计软件服务器处理并发的能力，比如能支持多少个用户同时访问。&lt;/li&gt;
&lt;li&gt;兼容性测试：不同的系统平台，或者不同的浏览器。&lt;/li&gt;
&lt;li&gt;提高测试效率，保证了产品的质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;适合自动化测试的场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试任务明确，不会频繁变动。&lt;/li&gt;
&lt;li&gt;软件需求变更较少。&lt;/li&gt;
&lt;li&gt;项目周期长，测试脚本可以复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;自动化测试的限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能取代手工测试，自动化测试只能提高测试效率，不能提高测试有效性，即不可能发现更多缺陷。&lt;/li&gt;
&lt;li&gt;手工测试比自动化测试发现的缺陷更多。&lt;/li&gt;
&lt;li&gt;对测试设计依赖性极大，测试设计的不好会遗漏问题。&lt;/li&gt;
&lt;li&gt;自动化测试对软件开发具有很大的依赖性，开发上出现变更可能导致前面的自动化测试完全失效。&lt;/li&gt;
&lt;li&gt;工具本身并不具备想象力。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>使用Docker部署Go的web应用</title>
        <link>https://kingsqiu.github.io/p/docker-goweb/</link>
        <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/docker-goweb/</guid>
        <description>&lt;h2 id=&#34;docker的必要性&#34;&gt;Docker的必要性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：在本地开发应用程序后，有很多的依赖环境或包，甚至对依赖的具体版本都有严格的要求。当开发过程完成后，若希望将应用程序部署到web服务器。这个时候必须确保所有依赖项都安装正确并且版本也完全相同，否则应用程序可能会崩溃并无法运行。如果想在另一个web服务器上也部署该应用程序，那么必须从头开始重复这个过程。这种场景就是Docker发挥作用的地方。&lt;/p&gt;
&lt;p&gt;对于运行应用程序的主机，不管是笔记本电脑还是web服务器，唯一需要做的就是运行一个docker容器平台。从以后，就不需要担心使用的是MacOS，Ubuntu，Arch还是其他。只需定义一次应用，即可随时随地运行。&lt;/p&gt;
&lt;h2 id=&#34;docker部署示例&#34;&gt;Docker部署示例&lt;/h2&gt;
&lt;h3 id=&#34;创建docker镜像&#34;&gt;创建Docker镜像&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;镜像（image）包含运行应用程序所需的所有东西——代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者简单地说，镜像（image）是定义应用程序及其运行所需的一切。&lt;/p&gt;
&lt;h3 id=&#34;编写dockerfile&#34;&gt;编写Dockerfile&lt;/h3&gt;
&lt;p&gt;要创建Docker镜像（image）必须在配置文件中指定步骤。这个文件默认为&lt;code&gt;Dockerfile&lt;/code&gt;。（虽然这个文件名可以随意命名它，但最好还是使用默认的&lt;code&gt;Dockerfile&lt;/code&gt;。）&lt;/p&gt;
&lt;p&gt;具体内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; golang:alpine&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 为我们的镜像设置必要的环境变量&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GO111MODULE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;on &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;CGO_ENABLED&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOOS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;linux &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;amd64

&lt;span class=&#34;c&#34;&gt;# 移动到工作目录：/build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将代码复制到容器中&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将我们的代码编译成二进制可执行文件app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; go build -o app .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 移动到用于存放生成的二进制文件的 /dist 目录&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /dist&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将二进制文件从 /build 目录复制到这里&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; cp /build/app .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 声明服务端口&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;EXPOSE&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; 8888&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 启动容器时运行的命令&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/dist/app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;dockerfile解析&#34;&gt;Dockerfile解析&lt;/h4&gt;
&lt;p&gt;官方文档：https://hub.docker.com/_/golang&lt;/p&gt;
&lt;p&gt;**From：**这里使用基础镜像&lt;code&gt;golang:alpine&lt;/code&gt;。是一个我们能够访问的存储在Docker仓库的基础镜像。这个镜像运行的是alpine Linux发行版，该发行版的大小很小并且内置了Go。&lt;/p&gt;
&lt;p&gt;**Env：**用来设置编译阶段需要用的环境变量。&lt;/p&gt;
&lt;p&gt;**EXPORT，CMD：**最后，声明服务端口，因为应用程序监听的是这个端口并通过这个端口对外提供服务。并且我们还定义了在我们运行镜像的时候默认执行的命令&lt;code&gt;CMD [&amp;quot;/dist/app&amp;quot;]&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;构建镜像&#34;&gt;构建镜像&lt;/h3&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HandleFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;:8888&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server startup...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server startup failed, err:%v\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello world&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在项目目录下，执行下面的命令创建镜像，并指定镜像名称为&lt;code&gt;goweb_app&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker build . -t goweb_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待构建过程结束，输出如下提示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;...
Successfully built 90d9283286b7
Successfully tagged goweb_app:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们已经准备好了镜像，但是目前它什么也没做。我们接下来要做的是运行我们的镜像，以便它能够处理我们的请求。运行中的镜像称为容器。&lt;/p&gt;
&lt;p&gt;执行下面的命令来运行镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -p 8888:8888 goweb_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标志位&lt;code&gt;-p&lt;/code&gt;用来定义端口绑定。由于容器中的应用程序在端口8888上运行，我们将其绑定到主机端口也是8888。如果要绑定到另一个端口，则可以使用&lt;code&gt;-p $HOST_PORT:8888&lt;/code&gt;。例如&lt;code&gt;-p 5000:8888&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在就可以测试下我们的web程序是否工作正常，打开浏览器输入&lt;code&gt;http://127.0.0.1:8888&lt;/code&gt;就能看到我们事先定义的响应内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hello world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;分阶段构建示例&#34;&gt;分阶段构建示例&lt;/h2&gt;
&lt;p&gt;Go程序编译之后会得到一个可执行的二进制文件，其实在最终的镜像中是不需要go编译器的，也就是说我们只需要一个运行最终二进制文件的容器即可。&lt;/p&gt;
&lt;p&gt;Docker的最佳实践之一是通过仅保留二进制文件来减小镜像大小，为此这里使用一种称为多阶段构建的技术，这意味着我们将通过多个步骤构建镜像。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; golang:alpine AS builder&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 为我们的镜像设置必要的环境变量&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GO111MODULE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;on &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;CGO_ENABLED&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOOS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;linux &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nv&#34;&gt;GOARCH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;amd64

&lt;span class=&#34;c&#34;&gt;# 移动到工作目录：/build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /build&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将代码复制到容器中&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 将我们的代码编译成二进制可执行文件 app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; go build -o app .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;###################&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 接下来创建一个小镜像&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;###################&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 从builder镜像中把/dist/app 拷贝到当前目录&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;builder /build/app /&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 需要运行的命令&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENTRYPOINT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这种技术，剥离了使用&lt;code&gt;golang:alpine&lt;/code&gt;作为编译镜像来编译得到二进制可执行文件的过程，并基于&lt;code&gt;scratch&lt;/code&gt;生成一个简单的、非常小的新镜像。将二进制文件从命名为&lt;code&gt;builder&lt;/code&gt;的第一个镜像中复制到新创建的&lt;code&gt;scratch&lt;/code&gt;镜像中。&lt;/p&gt;
&lt;p&gt;有关scratch镜像的更多信息，查看https://hub.docker.com/_/scratch&lt;/p&gt;
</description>
        </item>
        <item>
        <title>hugo博客使用笔记</title>
        <link>https://kingsqiu.github.io/p/hugo-blog-use/</link>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/hugo-blog-use/</guid>
        <description>&lt;h1 id=&#34;日常使用&#34;&gt;日常使用&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>文章配置</title>
        <link>https://kingsqiu.github.io/p/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://kingsqiu.github.io/p/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/</guid>
        <description>&lt;img src="https://kingsqiu.github.io/p/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/screenshot.png" alt="Featured image of post 文章配置" /&gt;&lt;h2 id=&#34;配置变量说明官网链接&#34;&gt;配置变量说明官网链接：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/content-management/front-matter/#front-matter-variables&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Front Matter Variables&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;YAML&lt;/strong&gt;, identified by ‘&lt;code&gt;---&lt;/code&gt;’.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;---
author: 
title: 
description: 
date: 2020-00-00
slug: 
image: 
categories:
    - 
tags: 
    - 
---
（四个空格，不要用两个tab）
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TOML&lt;/strong&gt;, identified by ‘&lt;code&gt;+++&lt;/code&gt;’.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;+++
author = &amp;quot;&amp;quot;
title = &amp;quot;&amp;quot;
description = &amp;quot;&amp;quot;
date = &amp;quot;2020-00-00&amp;quot;
slug = &amp;quot;&amp;quot;
image = &amp;quot;&amp;quot;
categories = [
    &amp;quot;&amp;quot;
]
tags = [
    &amp;quot;&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JSON&lt;/strong&gt;, a single JSON object which is surrounded by ‘&lt;code&gt;{&lt;/code&gt;’ and ‘&lt;code&gt;}&lt;/code&gt;’, each on their own line.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;title&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;date&amp;quot;: &amp;quot;2020-00-00&amp;quot;
    &amp;quot;slug&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;image&amp;quot;: &amp;quot;&amp;quot;
    &amp;quot;categories&amp;quot;: [
        &amp;quot;&amp;quot;
    ]
    &amp;quot;tags&amp;quot;: [
        &amp;quot;&amp;quot;
    ]    
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分类模板与图片示例&#34;&gt;分类模板与图片示例&lt;/h2&gt;
</description>
        </item>
        
    </channel>
</rss>
