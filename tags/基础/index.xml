<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础 on 盒木</title>
    <link>https://kingsqiu.github.io/tags/%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 基础 on 盒木</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 04 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://kingsqiu.github.io/tags/%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>测试基础方法</title>
      <link>https://kingsqiu.github.io/p/test-ways/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kingsqiu.github.io/p/test-ways/</guid>
      <description>黒、白、灰盒测试 黑盒测试 黑盒测试把被测对象看成一个黑匣子，只考虑期整体的特性，不考虑期内部具体实现。
黑盒测试的被测对象可以是一个系统、一个子系统、一模块、子模块、一个函数等。
黑盒测试又可以被称为基于规格的测试。
常见的黑盒测试类型：  功能性测试  一种是顺序测试每个程序特性或功能； 另一种是一个模块一个模块的测试，即每个功能在其最先调用的地方被测试；   容量测试，检测软件在处理海量数据时的局限性，能发现系统效率方面的问题。 负载测试，检测系统在短时间内处理巨大的数据量或执行许多功能调用上的能力。 恢复性测试，主要保证系统在崩溃后能回复外部数据的能力。  白盒测试 白盒测试是依据被测软件分析程序内部构造，并根据内部构造设计用例，来对内部控制流程进行测试，可完全不顾程序的整体功能实现情况。
白盒测试是基于程序结构的逻辑驱动测试。
白盒测试又可以被称为玻璃盒测试、透明盒测试、开放盒测试、结构化测试、逻辑驱动测试。
白盒测试一般在测试前期进行，通过达到一定的逻辑覆盖率指标，使得软件内部逻辑控制结构上的问题能基本得到解决。
白盒测试能保证内部逻辑结构能达到一定的覆盖程度，能够给予软件代码质量更大的保证。
白盒测试发现问题后解决问题的成本较低，毕竟介入的早嘛。
白盒测试一般会用到静态分析和动态分析两类技术，常用的有：
 静态分析：控制流分析、数据流分析、信息流分析； 动态分析：逻辑覆盖测试（分支测试、路径测试等）、程序插桩等。  白盒测试的特点  测试人员需要了解软件的实现； 可以检测代码中的每一条分支和路径； 揭示隐藏在代码代码中的错误； 对代码的测试相对彻底； 实现代码结构上的优化； 白盒测试的投入较大，成本高； 白盒测试不验证（需求）规格的正确性；  逻辑覆盖率测试 根据覆盖的对象不同，存在多种逻辑覆盖测试：
 语句覆盖； 判定覆盖； 条件覆盖； 判定-条件覆盖； 路径覆盖； 等  而逻辑覆盖率的统计是通过程序插桩来实现的。
程序插桩：程序插桩，最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针（又称为“探测仪”，本质上就是进行信息采集的代码段，可以是赋值语句或采集覆盖信息的函数调用），通过探针的执行并抛出程序运行的特征数据，通过对这些数据的分析，可以获得程序的控制流和数据流信息，进而得到逻辑覆盖等动态信息，从而实现测试目的的方法。
简单来说，程序插桩就是我们在调试程序时，常常要在程序中插入一些打印语句（想想我们在程序中常用的print语句），其目的是希望在程序执行中打印出我们最为关心的信息，然后进一步通过这些信息了解程序执行过程中程序的一些动态特性。
从这一思想发展出程序插桩技术能够按照用户的要求，获取程序的各种信息，成为测试工作的有效测试手段。
灰盒测试 根据利用的被测对象的信息不同，会采用不同的方法进行测试，一般的：
 利用被测对象的整体特性信息，采用黑盒测试方法。 利用被测对象的内部具体实现信息，采用白盒测试方法。 如果既是利用被测对象的整体特性信息，又利用被测对象的内部具体实现信息，采用的就是灰盒测试方法。两种信息占比不同，相应的灰度就不同，完全是整体特性信息，就是黑盒测试，完全是内部具体实现信息，就是白盒测试。  黑、白、灰盒测试方法总结 我们一般从以下五个维度来区分：
 测试阶段不同：  单元测试阶段主要利用白盒测试方法。 集成测试阶段主要利用灰盒测试方法。 系统测试阶段主要利用黑盒测试方法。   测试依据，因为测试阶段的不同，采用的测试方法也不同，那它们的测试依据也不同：  白盒测试主要依据详细测试说明书（LLD）。 黑盒测试主要依据需求规格（设计）说明书（SRS）。 灰盒测试主要依据概要规格（设计）说明书（HLD）。   测试方法：  白盒测试方法可以有静态和动态，控制流、信息流、数据流、各种覆盖率、插桩处理。 黑盒测试方法有各种测试类型（功能型、负载、恢复性），以及应用等价类、边界值、流程图法、正交法等。 灰盒测试这里即用白盒的，也用黑盒的。   评估基准：  白盒根据逻辑覆盖率来评估。 黑盒主要看需求规格的覆盖率。 灰盒主要看接口覆盖率。   特点不一样：  白盒测试，特点是及早的发现问题，定位问题也很快，缺点是对接口、对设计、程序之间的调用、用户感受也不是很好。 黑盒解决问题的代价比较大，很大发现模块内部的问题。    静态、动态测试 软件研发可以看成是一个生产过程，在此过程中会有产品输出或者称为工件输出。</description>
    </item>
    
  </channel>
</rss>
